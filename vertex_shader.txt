#version 330 core

// Input vertex data, different for all executions of this shader.
layout(location = 0) in vec3 vertexPosition_modelspace;
layout(location = 1) in vec2 vertexUV;
layout(location = 2) in vec3 vertexNormal_modelspace;

// 输出的顶点颜色
out vec2 uv;
out vec3 Position_worldspace;
out vec3 Normal_cameraspace;
out vec3 EyeDirection_cameraspace;
out vec3 LightDirection_cameraspace;

uniform mat4 MVP;
uniform mat4 V;
uniform mat4 M;
uniform vec3 LightPosition_worldspace;
uniform float time_value;

vec3 erot(vec3 p, vec3 ax, float ro){
    return mix(dot(ax,p)*ax, p, cos(ro)) + cross(ax, p)*sin(ro);
}

void main(){
    float angle = time_value;

    mat4 r = mat4(
        cos(angle), 0.0, sin(angle),  0.0,
        0.0, 1.0, 0.0, 0.0, 
        -sin(angle), 0.0, cos(angle), 0.0,
        0.0, 0.0, 0.0, 1.0
    );

    // 旋转后的顶点位置
    //vec4 rotated_model_pos =  vec4(erot(vertexPosition_modelspace, vec3(0,1,0), angle), 1.0f);
    vec4 rotated_model_pos = r * vec4( vertexPosition_modelspace, 1.0f);

    // 输出的顶点位置，在剪裁空间内
    gl_Position = MVP * rotated_model_pos;

    // 世界空间的顶点位置
    Position_worldspace = (M * rotated_model_pos).xyz;


    // 相机空间的顶点位置
    vec3 vertexPosition_cameraspace = (V * M * rotated_model_pos).xyz;
    // 从顶点进入相机的向量，相机空间
    EyeDirection_cameraspace = vec3(0,0,0) - vertexPosition_cameraspace;

    // 相机空间的光源位置，M被省略了，因为它是单位矩阵
    vec3 LightPosition_cameraspace = (V * vec4(LightPosition_worldspace, 1.0f)).xyz;
    // 从顶点到光源的向量，相机空间
    LightDirection_cameraspace = LightPosition_cameraspace + EyeDirection_cameraspace;

    // 相机空间的顶点法线
    Normal_cameraspace = (V * M * vec4(vertexNormal_modelspace, 0.0f)).xyz;

    // 顶点UV
    uv = vertexUV;
}
